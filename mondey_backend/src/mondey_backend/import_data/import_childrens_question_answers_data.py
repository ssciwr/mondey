"""
This file should parse each column and if it is a childs question, save it.
Select options will (as in `ChildQuestion` class/SQL model) just be saved as plaintext answers.

Care must be taken for freetext options. Those seem to be generally indicated by a "_" or "_01" affix to the question,
e.g.:

FE03 <-- will be a code-mapped answer
FE03_01 <-- optional freetext answer (when present, overwrites the code-mapped answer)

They are also easy to tell apart because the "Type" will be "TEXT" not "ORDINAL". e.g.

FE01 <-- ORDINAL (e.g. 1, 2, 3, 4, 5, 6, 7 -9) (where these are mapped to 1 = Deutschland, 2 = Sweden, usw).
FE01_031 <-- TEXT (e.g. "Frankreich")

Notes:

    We use variable + ': ' + variable_label for the question ID (so "FE06: Geburtsjahr") because there are some
    complexities in the question mapping from the SoSci data, especially:
    1) For answers, each possibly mappable answer response duplicates the question...
    e.g.
    Variable | Name | Code | Label
    FE04 Geburtsjahr 1 2024
    FE04 Geburtsjahr 2 2023
    FE04 Geburtsjahr 3 2022

    ... But more than this...

    The same question might appear again (e.g. in reference to the Parent/Beobachter, not the child):
    Variable | Name | Code | Label
    FK04 Geburtsjahr 1 1972
    FK04 Geburtsjahr 2 1973
    FK04 Geburtsjahr 3 1974

    So the *same Name*, *same Codes*, but Different Labels if the "Variable" (really "variable ID") is the same.
    Since variable ID also gets duplicated nAnswers times, the logic keeps within our system the variable tag
    alongside the label at all times. This way we can be sure we actually have got the respective FE04 vs FK04
    Geburtsjahr question/answers data, to avoid confusing those two. This way is also more dynamic. No combinations
    (because of how SoSci exports) should ever have the same variable and name unless they are mapping the same set
    of answers, like our code processed them. Yes it does mean in the UI the "Variable"(string ID) will appear as a
    prefix, but that's a great traddeoff to have certainty in the variables being in the actual data.
"""

import json

import pandas as pd
from sqlmodel import select

from mondey_backend.import_data.utils import clear_all_data
from mondey_backend.import_data.utils import data_path
from mondey_backend.import_data.utils import get_childs_parent_id
from mondey_backend.import_data.utils import get_import_test_session
from mondey_backend.import_data.utils import get_question_filled_in_to_parent
from mondey_backend.import_data.utils import labels_path
from mondey_backend.import_data.utils import questions_configured_path
from mondey_backend.import_data.utils import save_select_question
from mondey_backend.import_data.utils import save_text_question
from mondey_backend.models.milestones import Language
from mondey_backend.models.questions import ChildAnswer
from mondey_backend.models.questions import ChildQuestion
from mondey_backend.models.questions import ChildQuestionText
from mondey_backend.models.questions import UserAnswer
from mondey_backend.models.questions import UserQuestion
from mondey_backend.models.questions import UserQuestionText

debug = True

satisfyPreCommitUnusedImportRemover = type(Language) is str


def prepare_options_json(options):
    """
    The first draft was generated by Cladue AI, to match the examples in conftest and the data format
    <select> on the frontend appears to take as input (according to Props) for Svelte Flowbite Select.
    Prepare options JSON with value, name, and disabled properties.

    Args:
        options (pd.DataFrame): DataFrame with 'Response Code' and 'Response Label' columns

    Returns:
        tuple: A tuple containing:
            - options_json (str): JSON string of options
            - options_str (str): Comma-separated list of options for display
    """
    # Filter out invalid options
    valid_options = options[options["Response Code"] != -9]

    # Prepare options with proper escaping and structure
    prepared_options = []
    options_display = []

    for _, row in valid_options.iterrows():
        # Escape commas and other potential problematic characters in the label
        escaped_label = row["Response Label"].replace(",", "&#44;")

        option = {
            "value": str(row["Response Code"]),  # Convert to string
            "name": escaped_label,
            "disabled": False,
        }
        prepared_options.append(option)
        options_display.append(escaped_label)

    # Convert to JSON string
    options_json = json.dumps(prepared_options)

    # Create comma-separated string of options (with escaped labels)
    options_str = ", ".join(options_display)

    return options_json, options_str


def import_childrens_question_answers_data(
    session,
    labels_path: str,
    data_path: str,
    questions_configured_path: str,
    clear_existing_questions_and_answers: bool = False,
):
    if debug:
        print("Opening labels path: ", labels_path)
        print("Opening data path: ", data_path)
    if satisfyPreCommitUnusedImportRemover:
        print("Satisfied pre-commit so we can have language model table access...")

    labels_df = pd.read_csv(
        labels_path,
        sep=",",
        encoding="utf-16",
        encoding_errors="replace",
        index_col=None,
    )
    data_df = pd.read_csv(
        data_path, sep="\t", encoding="utf-16", encoding_errors="replace"
    )
    questions_configured_df = pd.read_csv(
        questions_configured_path,
        sep=",",
        encoding="utf-8",
        dtype=str,
        encoding_errors="replace",
    )
    questions_configured_df.columns = questions_configured_df.columns.str.strip()

    if clear_existing_questions_and_answers:
        clear_all_data(session)

    free_text_questions = []

    # Dictionary to track the previous variable for handling 'Andere' cases
    previous_variable_label = None

    # Process each unique variable in labels_df
    processed_variables = set()
    if debug:
        print("Sample data:")
        print(labels_df.head(5))

    if debug:
        print(
            "Now filtering out the milestones, so we only consider manual questions. This is unfortunately hardcoded."
        )

    labels_df = labels_df.loc[(labels_df.index > 170) & (labels_df.index < 396)]

    if debug:
        print("Sample data:")
        print(labels_df.head(100))

    for _uj, label_row in (
        labels_df.groupby("Variable").first().reset_index().iterrows()
    ):
        variable = label_row["Variable"]
        if debug:
            print(label_row)
            print("has variable: ", variable)

        # Skip if already processed
        if variable in processed_variables:
            continue
        processed_variables.add(variable)

        # Determine question type and properties
        variable_type = label_row["Variable Type"]
        input_type = label_row["Input Type"]
        variable_label = label_row["Variable Label"]

        # Handling different variable types
        if (
            variable_type == "NOMINAL" or variable_type == "ORDINAL"
        ) and input_type == "MC":
            if debug:
                print(
                    "Handling Multiple Choice with optinos.. should be saved as separated text strings"
                )
            # Multiple Choice Question
            print("Should just be saved.")
            options = labels_df[labels_df["Variable"] == variable]
            if debug:
                print("Options found were: ", options)

            # Filter out non-response codes
            valid_options = options[options["Response Code"] != -9]

            # Prepare options JSON
            options_dict = {
                str(row["Response Code"]): row["Response Label"]
                for _, row in valid_options.iterrows()
            }

            if debug:
                print("Sample options: ", options_dict)

            options_json, options_str = prepare_options_json(options)

            save_select_question(
                variable,
                variable_label,
                options_json,
                options_str,
                questions_configured_df,
                session,
            )

            # Track this as the previous variable for potential 'Andere' handling
            previous_variable_label = variable_label
            # previous_variable_label = variable_label

        elif variable_type == "TEXT" and input_type == "TXT":
            # These are free text questions
            if (
                type(variable_label) is str
                and ": [01]" in variable_label
                and (
                    previous_variable_label
                    and f"{previous_variable_label}: [01]" in variable_label
                )
            ):  # only if they match
                # = it's an other free text input, we handle in geenral data processing rules for TEXT variable type later.
                if debug:
                    print(
                        "Not creating question for this Other option - its free text response will be merged"
                    )
                continue
                """
                Note that some samples should not trigger this... for example:
                 FK04_01: FrÃ¼hgeboren
                The previous question is on FK03,Termingebunden? so this one gets kept.
                Whereas Muttersprache, it's like
                FE04,Muttersprache,1,Deutsch,NOMINAL,MC
                FE04,Muttersprache,2,Andere,NOMINAL,MC
                FE04,Muttersprache,-9,nicht beantwortet,NOMINAL,MC
                FE05_01,Andere Muttersprache: [01],,,TEXT,TXT
                ... where "Muttersprache" is in common.
                """

            # Independent free text question
            free_text_questions.append((variable, variable_label))

            save_text_question(
                variable,
                variable_label,
                previous_variable_label,
                questions_configured_df,
                session,
            )
            if debug:
                print("Added text feetex tquestion type..")
        else:
            if debug:
                print(
                    "Question case was not hanlded... need to pay attention to this..",
                    variable_label,
                    variable_type,
                    input_type,
                )

    session.commit()
    print("All questions have been generated. Now assigning answers to them")
    assign_answers_to_the_imported_questions(
        session, data_df, labels_df, questions_configured_df
    )


def assign_answers_to_the_imported_questions(
    session, data_df, labels_df, questions_configured_df
):
    questions_to_discard = []
    total_answers = 0
    missing = 0
    # missing_csv_questions = 0

    # Process actual data into child answers
    for _, child_row in data_df.iterrows():
        # Iterate through all variables in labels_df
        for _j, label_row in (
            labels_df.groupby("Variable").first().reset_index().iterrows()
        ):
            variable_type = label_row["Variable Type"]
            variable = label_row["Variable"]
            variable_label = label_row["Variable Label"]
            is_parent_question = False  # default assumption that it is a child question

            if variable_label in questions_to_discard:
                continue

            # The below enables us to find all 3 categories of possible questions for these answers:
            """
            Category 1 - variable_label is question (most questions): Just finds it as child or user question.
            Category 2 - variable_label is a free text reference, but to a question with choices. In this case,
            the replaced version will find the right original question to "overwrite" the "Other" answer with
            the freetext from the users data.
            Category 3 - variable_label is a free text reference, but not connected to another question. In this case,
            it will be found through variable level like any other question.
            """
            for variable_label_option in [
                variable_label,
                variable_label.replace(" [01]", "").replace("Andere ", ""),
            ]:
                # Find the corresponding ChildQuestion
                query = (
                    select(ChildQuestion)
                    .join(ChildQuestionText)
                    .where(
                        ChildQuestionText.lang_id == 1,
                        ChildQuestionText.question
                        == variable + ": " + variable_label_option,
                    )
                )

                question = session.exec(query).first()

                # todo: Now we know FK = Children, FE/FP = Parents, we could use IF rather than fallback for this.
                if not question:
                    query = (
                        select(UserQuestion)
                        .join(UserQuestionText)
                        .where(
                            UserQuestionText.lang_id == 1,
                            UserQuestionText.question
                            == variable + ": " + variable_label_option,
                        )
                    )

                    question = session.exec(query).first()

            # If after all looping no match is found, discard.
            if not question:
                print(
                    "Discarding question answer without found saved question (which was deliberately not saved, maybe because it was a milestone etc): ",
                    variable,
                    label_row["Variable Label"],
                )
                questions_to_discard.append(variable)
                continue

            # Get the child's response for this variable
            response = child_row.get(variable)

            # Skip if no response
            if pd.isna(response) or response == -9:
                continue

            if debug and is_parent_question:
                print("Is parent question.")
                if "FE" in variable:
                    print("FE variable! ", variable)

            # Handle Multiple Choice
            if variable_type == "NOMINAL" or variable_type == "ORDINAL":
                if debug:
                    print("Came across nominal...")
                response_label = labels_df[
                    (labels_df["Variable"] == variable)
                    & (labels_df["Response Code"] == response)
                ]
                if debug:
                    print(
                        "Response/Response label: ", response, "../..", response_label
                    )
                    print("ANd desired variable: ", variable)

                if not response_label.empty:
                    answer_text = response_label.iloc[0]["Response Label"]
                    if debug:
                        print(
                            "Answer leg assigned for response code: ",
                            response,
                            " was: ",
                            answer_text,
                        )

                    # if is_parent_question: # then we need to go ahead and save it to the user_id for this child
                    # now we need to bulk create the parents for each child in the 1st script.
                    if get_question_filled_in_to_parent(
                        questions_configured_df, variable, debug_print=True
                    ):
                        print("Saving user answer!")
                        answer = UserAnswer(
                            user_id=get_childs_parent_id(child_row["CASE"]),
                            question_id=question.id,
                            answer=answer_text,
                        )
                        print(
                            "Saved with ID of...:",
                            get_childs_parent_id(child_row["CASE"]),
                        )
                    else:
                        print(
                            "Would have looked up isToParent Y status for: ", variable
                        )
                        answer = ChildAnswer(
                            child_id=child_row["CASE"],
                            question_id=question.id,
                            answer=answer_text,
                        )
                    total_answers += 1
                    session.add(answer)

            elif variable_type == "TEXT":
                if ": [01]" in variable:
                    if debug:
                        print("Free text Andere triggered!")
                    # Look for free text input
                    free_text_var = f"{variable}_01"
                    free_text_answer = child_row.get(free_text_var)

                    if not pd.isna(free_text_answer):
                        answer_text = str(free_text_answer)
                if get_question_filled_in_to_parent(questions_configured_df, variable):
                    print("Saving user answer2!")
                    answer = UserAnswer(
                        user_id=get_childs_parent_id(child_row["CASE"]),
                        question_id=question.id,
                        answer=str(response),
                    )
                    print(
                        "Saved with ID of...:", get_childs_parent_id(child_row["CASE"])
                    )
                else:
                    print("Saving child answer..")
                    answer = ChildAnswer(
                        child_id=child_row["CASE"],
                        question_id=question.id,
                        answer=str(response),
                    )
                # not sure this will work for free text other cases.
                total_answers += 1
                session.add(answer)
            else:
                print("Variable type has no clear processing method! Warning.")
                print(
                    variable_type,
                    "... it has the variable type/label:",
                    variable_type,
                    variable_label,
                )
                missing += 1

    session.commit()
    if debug:
        print("Total answers saved: ", total_answers)
        print(
            "Missing (unable to deal with answers, to which we saved the questions, so wanted the answers): ",
            missing,
        )


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 1 or len(sys.argv) > 2:
        print(
            "Usage: python import_childrens_question_answers_data.py <?clear_existing_questions bool>"
        )
        sys.exit(1)

    clear_existing_questions_and_answers = False
    if len(sys.argv) > 1:
        clear_existing_questions_and_answers = sys.argv[1] == "true"

    if clear_existing_questions_and_answers and (
        input(
            "This will wipe your DB data on questions/answers! Are you certain you want to *delete all such data*? (y/n)"
        )
        != "y"
    ):
        exit()

    import_session, import_engine = get_import_test_session()

    import_childrens_question_answers_data(
        import_session,
        labels_path,
        data_path,
        questions_configured_path,
        clear_existing_questions_and_answers=clear_existing_questions_and_answers,
    )

"""
This file should parse each column and if it is a childs question, save it.
Select options will (as in `ChildQuestion` class/SQL model) just be saved as plaintext answers.

Care must be taken for freetext options. Those seem to be generally indicated by a "_" or "_01" affix to the question,
e.g.:

FE03 <-- will be a code-mapped answer
FE03_01 <-- optional freetext answer (when present, overwrites the code-mapped answer)

They are also easy to tell apart because the "Type" will be "TEXT" not "ORDINAL". e.g.

FE01 <-- ORDINAL (e.g. 1, 2, 3, 4, 5, 6, 7 -9) (where these are mapped to 1 = Deutschland, 2 = Sweden, usw).
FE01_031 <-- TEXT (e.g. "Frankreich")

Notes:

    We use variable + ': ' + variable_label for the question ID (so "FE06: Geburtsjahr") because there are some
    complexities in the question mapping from the SoSci data, especially:
    1) For answers, each possibly mappable answer response duplicates the question...
    e.g.
    Variable | Name | Code | Label
    FE04 Geburtsjahr 1 2024
    FE04 Geburtsjahr 2 2023
    FE04 Geburtsjahr 3 2022

    ... But more than this...

    The same question might appear again (e.g. in reference to the Parent/Beobachter, not the child):
    Variable | Name | Code | Label
    FK04 Geburtsjahr 1 1972
    FK04 Geburtsjahr 2 1973
    FK04 Geburtsjahr 3 1974

    So the *same Name*, *same Codes*, but Different Labels if the "Variable" (really "variable ID") is the same.
    Since variable ID also gets duplicated nAnswers times, the logic keeps within our system the variable tag
    alongside the label at all times. This way we can be sure we actually have got the respective FE04 vs FK04
    Geburtsjahr question/answers data, to avoid confusing those two. This way is also more dynamic. No combinations
    (because of how SoSci exports) should ever have the same variable and name unless they are mapping the same set
    of answers, like our code processed them. Yes it does mean in the UI the "Variable"(string ID) will appear as a
    prefix, but that's a great traddeoff to have certainty in the variables being in the actual data.
"""

import json

import pandas as pd
from sqlmodel import select
from tqdm import tqdm

from mondey_backend.import_data.utils import data_path
from mondey_backend.import_data.utils import get_childs_parent_id
from mondey_backend.import_data.utils import get_import_test_session
from mondey_backend.import_data.utils import get_question_filled_in_to_parent
from mondey_backend.import_data.utils import labels_path
from mondey_backend.import_data.utils import questions_configured_path
from mondey_backend.import_data.utils import save_select_question
from mondey_backend.import_data.utils import save_text_question
from mondey_backend.import_data.utils import update_or_create_user_answer
from mondey_backend.models.milestones import Language
from mondey_backend.models.questions import ChildAnswer
from mondey_backend.models.questions import ChildQuestion
from mondey_backend.models.questions import ChildQuestionText
from mondey_backend.models.questions import UserQuestion
from mondey_backend.models.questions import UserQuestionText

debug = True

satisfyPreCommitUnusedImportRemover = type(Language) is str


def prepare_options_json(options):
    """
    The first draft was generated by Cladue AI, to match the examples in conftest and the data format
    <select> on the frontend appears to take as input (according to Props) for Svelte Flowbite Select.
    Prepare options JSON with value, name, and disabled properties.

    Args:
        options (pd.DataFrame): DataFrame with 'Response Code' and 'Response Label' columns

    Returns:
        tuple: A tuple containing:
            - options_json (str): JSON string of options
            - options_str (str): Comma-separated list of options for display
    """
    # Filter out invalid options
    valid_options = options[options["Response Code"] != -9]

    # Prepare options with proper escaping and structure
    prepared_options = []
    options_display = []

    for _, row in valid_options.iterrows():
        # Escape commas and other potential problematic characters in the label
        escaped_label = row["Response Label"].replace(",", "&#44;")

        option = {
            "value": str(row["Response Code"]),  # Convert to string
            "name": escaped_label,
            "disabled": False,
        }
        prepared_options.append(option)
        options_display.append(escaped_label)

    # Convert to JSON string
    options_json = json.dumps(prepared_options)

    # Create comma-separated string of options (with escaped labels)
    options_str = ";".join(options_display)

    return options_json, options_str


def import_childrens_question_answers_data(
    session,
    labels_path: str,
    data_path: str,
    questions_configured_path: str,
):
    """
    This loads the "labels_df" which is in social science terms a "coding codebook". It lists several variables, which
    represent Milestones and Questions in our system, with IDs like "DE01_02". It also lists answer options for each
    "variable" with a mapping pairing, which "codes" the survey data value to the actual (text) answer. For example,
    1 = 2024, 2 = 2023, 3 = 2020. The labels_df tells us this mapping for the question "FK_01", with the title,
    "Geburtsjahr" - Year of birth.

    Questions can include "codes" like -9, which means "no answer given".

    This coding mapping is then used by the second main function in this file, assign_answers_to_the_imported_questions,
    which uses the "data_path" dataframe. The data dataframe contains the codes for each child, so it provides a way to
    map the actual answers, "using" the codebook. The second function maps those codes to save the real, true freetext
    answers, which are compatible and match the questions saved by this function.

    :param session: Important: This should be the import_session, so that we can keep it in it's own DB/folder location
    (/import_data/db by default)
    :param clear_existing_questions_and_answers: A dataframe which includes whether a question is directed to parents (so, a
    UserQuestion/UserAnswer), such as income/Social Economic Status, or about/to the child (ChildQuestion/ChildAnswer)
    :return:
    """
    if debug:
        print("Opening labels path: ", labels_path)
        print("Opening data path: ", data_path)
    if satisfyPreCommitUnusedImportRemover:
        print("Satisfied pre-commit so we can have language model table access...")

    labels_df = pd.read_csv(
        labels_path,
        sep=",",
        encoding="utf-16",
        encoding_errors="replace",
        index_col=None,
    )
    data_df = pd.read_csv(
        data_path, sep="\t", encoding="utf-16", encoding_errors="replace"
    )
    questions_configured_df = pd.read_csv(
        questions_configured_path,
        sep=",",
        encoding="utf-8",
        dtype=str,
        encoding_errors="replace",
    )
    questions_configured_df.columns = questions_configured_df.columns.str.strip()

    free_text_questions = []

    # Dictionary to track the previous variable for handling 'Andere' cases
    previous_variable_label = None

    # Process each unique variable in labels_df
    processed_variables = set()
    if debug:
        print("Sample data:")
        print(labels_df.head(5))

    if debug:
        print(
            "Now filtering out the milestones, so we only consider manual questions. This is unfortunately hardcoded."
        )

    labels_df = labels_df.loc[(labels_df.index > 170) & (labels_df.index < 395)]

    if debug:
        print("Sample data:")
        print(labels_df.head(100))

    for _uj, label_row in (
        labels_df.groupby("Variable").first().reset_index().iterrows()
    ):
        variable = label_row["Variable"]
        if debug:
            print(label_row)
            print("has variable: ", variable)

        # Skip if already processed
        if variable in processed_variables:
            continue
        processed_variables.add(variable)

        # Determine question type and properties
        variable_type = label_row["Variable Type"]
        input_type = label_row["Input Type"]
        variable_label = label_row["Variable Label"]

        # Handling different variable types
        if (
            (variable_type == "NOMINAL" or variable_type == "ORDINAL")
            and input_type == "MC"
        ) or (variable_type == "DICHOTOMOUS" and input_type == "CK"):
            if debug:
                print(
                    "Handling Multiple Choice with options.. should be saved as separated text strings"
                )
            # Multiple Choice Question
            print("Should just be saved.")
            options = labels_df[labels_df["Variable"] == variable]
            if debug:
                print("Options found were: ", options)

            # Filter out non-response codes
            valid_options = options[options["Response Code"] != -9]

            # Prepare options JSON
            options_dict = {
                str(row["Response Code"]): row["Response Label"]
                for _, row in valid_options.iterrows()
            }

            if debug:
                print("Sample options: ", options_dict)

            options_json, options_str = prepare_options_json(options)

            save_select_question(
                variable,
                variable_label,
                options_json,
                options_str,
                questions_configured_df,
                session,
            )

            # Track this as the previous variable for potential 'Andere' handling
            previous_variable_label = variable_label
            # previous_variable_label = variable_label

        elif variable_type == "TEXT" and input_type == "TXT":
            # These are free text questions
            if (
                type(variable_label) is str
                and ": [01]" in variable_label
                and (
                    previous_variable_label
                    and f"{previous_variable_label}: [01]"
                    in variable_label  # this line checks if previous was a select
                    # situation or whether it's an actual indepedent free text question (then will be False)
                )
            ):  # only if they match
                """
                In this IF case, it's an other free text input, we handle in general data processing rules for TEXT
                variable type later on, so we "continue".

                Note that some samples should not trigger this... for example:
                 FK04_01: FrÃ¼hgeboren
                The previous question is on FK03,Termingebunden? so this one gets kept.
                Whereas Muttersprache, it's like
                FE04,Muttersprache,1,Deutsch,NOMINAL,MC
                FE04,Muttersprache,2,Andere,NOMINAL,MC
                FE04,Muttersprache,-9,nicht beantwortet,NOMINAL,MC
                FE05_01,Andere Muttersprache: [01],,,TEXT,TXT
                ... where "Muttersprache" is in common.
                """
                if debug:
                    print(
                        "Not creating question for this Other option - its free text response will be merged"
                    )
                continue

            # Independent free text question
            free_text_questions.append((variable, variable_label))

            save_text_question(
                variable,
                variable_label,
                previous_variable_label,
                questions_configured_df,
                session,
            )
            if debug:
                print("Added text feetex tquestion type..")
        else:
            if debug:
                print(
                    "Question case was not hanlded... need to pay attention to this..",
                    variable_label,
                    variable_type,
                    input_type,
                )

    session.commit()
    print("All questions have been generated. Now assigning answers to them")
    assign_answers_to_the_imported_questions(
        session, data_df, labels_df, questions_configured_df
    )


def assign_answers_to_the_imported_questions(
    session, data_df, labels_df, questions_configured_df
):
    """
    Once the questions have been inserted into UserQuestion and ChildQuestion, we need to add answers.
    This script works out the coding mappings for answers* and then connects the relevant answer and child/user ID
    to save answers for each question.

    Once complete the answers will all be imported. The logic deals with "free text other" answers by saving them
    as their own answer (as simple "answer property") if they are an independent question, or by saving it as
    "additioanl_answer" if it is connected to a select question, e.g.

    "Name": Independent free text, saves "answer" to the question.
    "Other Nationality": Exists with the "Nationality" Select question, which has an option for Other (Andere).
    When uses select Other, this one will be filled out. In that case, we set the additional answer to the "Nationality"
    question with the answer from this text field, rather than saving it as its own independent question. This leaves
    it looking like so:
    answer: "Andere", additional_answer: "Users Free text answer".

    When answers already exist for a given child/user ID, it will not insert a second answer. This is to support importing
    additional data.

    :param questions_configured_df: A dataframe which includes whether a question is directed to parents (so, a
    UserQuestion/UserAnswer), such as income/Social Economic Status, or about/to the child (ChildQuestion/ChildAnswer)

    """
    questions_to_discard = [
        "FK01",
        "FK02",
    ]  # Child date of month/year: Already assigned to each child.
    total_answers = 0
    missing = 0

    # Get all unique child_ids that already have answers
    results = session.query(ChildAnswer.child_id).distinct().all()
    # Extract the ids into a list
    children_ids_with_data = [result[0] for result in results]

    print("Children IDs which were already covered by answers:", children_ids_with_data)

    # Process actual data into child answers
    for _, child_row in tqdm(data_df.iterrows()):
        print("")
        print("")
        print("")
        # First: If the child has any answers, we assume their data is complete (previously imported). So skip such children
        if child_row.get("CASE") in children_ids_with_data:
            print("Skipping done child:", child_row.get("CASE"))
            continue
        else:
            print("Adding answers for child: ", child_row.get("CASE"))
        # Iterate through all variables in labels_df
        print("")
        print("Going through for child ... ", child_row.get("CASE"))
        previous_variable_label = "Default Label"
        previous_variable = "Default Variable"
        for _j, label_row in (
            labels_df.groupby("Variable").first().reset_index().iterrows()
        ):
            variable_type = label_row["Variable Type"]
            variable = label_row["Variable"]
            variable_label = label_row["Variable Label"]
            is_parent_question = False  # default assumption that it is a child question

            if variable_label in questions_to_discard:
                continue

            # The below enables us to find all 3 categories of possible questions for these answers:
            """
            Category 1 - variable_label is question (most questions): Just finds it as child or user question.
            Category 2 - variable_label is a free text reference, but to a question with choices. In this case,
            the replaced version will find the right original question to "overwrite" the "Other" answer with
            the freetext from the users data.
            Category 3 - variable_label is a free text reference, but not connected to another question. In this case,
            it will be found through variable level like any other question.
            """
            for variable_label_option in [
                variable_label,
            ]:
                preserved_freetext_lookup_key = variable
                set_only_additional_answer = False
                if (
                    " [01]" in variable_label
                    and "Andere" in variable_label
                    and previous_variable_label in variable_label
                ):  # indicates it's linked to previous label (select)
                    set_only_additional_answer = True
                    variable_label_option = previous_variable_label
                    variable = previous_variable
                    print("Was linked to previous select, so setting additional answer")
                    print(variable + ": " + variable_label_option)

                # Find the corresponding ChildQuestion
                query = (
                    select(ChildQuestion)
                    .join(ChildQuestionText)
                    .where(
                        ChildQuestionText.lang_id == "de",
                        ChildQuestionText.question == variable_label_option,
                    )
                )

                question = session.exec(query).first()

                # todo: Now we know FK = Children, FE/FP = Parents, we could use IF rather than fallback for this.
                if not question:
                    query = (
                        select(UserQuestion)
                        .join(UserQuestionText)
                        .where(
                            UserQuestionText.lang_id == "de",
                            UserQuestionText.question == variable_label_option,
                        )
                    )

                    question = session.exec(query).first()
                    print(
                        "Intiiated latest search for ...:",
                        variable + ": " + variable_label_option,
                    )

            # If after all looping no match is found, discard.
            if not question:
                print(
                    "Discarding question answer without found saved question (which was deliberately not saved, maybe because it was a milestone etc): ",
                    variable,
                    label_row["Variable Label"],
                )
                questions_to_discard.append(variable)
                # raise("This should not happen")
                continue

            # Get the child's response for this variable
            response = child_row.get(variable)
            answer_text = str(response)  # safe default for free text answers.

            # Skip if no response
            if pd.isna(response) or response == -9:
                continue

            if debug and is_parent_question:
                print("Is parent question.")
                if "FE" in variable:
                    print("FE variable! ", variable)

            # Handle Multiple Choice
            if (
                variable_type == "NOMINAL"
                or variable_type == "ORDINAL"
                or variable_type == "DICHOTOMOUS"
            ):
                if debug:
                    print("Came across select question type...")
                response_label = labels_df[
                    (labels_df["Variable"] == variable)
                    & (labels_df["Response Code"] == response)
                ]
                if debug:
                    print(
                        "Response/Response label: ", response, "../..", response_label
                    )
                    print("ANd desired variable: ", variable)

                if not response_label.empty:
                    answer_text = response_label.iloc[0]["Response Label"]
                    print("Saving answer:", answer_text)

                    if get_question_filled_in_to_parent(
                        questions_configured_df, variable, debug_print=True
                    ):
                        found_base_question, answer = update_or_create_user_answer(
                            session,
                            user_or_child_id=get_childs_parent_id(
                                session, child_row["CASE"]
                            ),
                            question_id=question.id,
                            answer_text=answer_text,
                            set_only_additional_answer=False,
                            is_child_question=False,
                        )
                        print(
                            "Saved(user question) with parent ID of...:",
                            get_childs_parent_id(session, child_row["CASE"]),
                        )
                    else:
                        print(
                            "Would have looked up isToParent Y status for: ", variable
                        )
                        found_base_question, answer = update_or_create_user_answer(
                            session,
                            user_or_child_id=child_row["CASE"],
                            question_id=question.id,
                            answer_text=answer_text,
                            set_only_additional_answer=set_only_additional_answer,
                            is_child_question=True,
                        )
                    total_answers += 1
                    session.add(answer)

            elif variable_type == "TEXT":
                print("Encountered text variable type.", variable, variable_label)
                if " [01]" in variable_label and "Andere" in variable_label:
                    if debug:
                        print("Free text Andere triggered!", variable, variable_label)

                    set_only_additional_answer = True

                response = child_row.get(
                    preserved_freetext_lookup_key
                )  # For free text, always use the actual look up
                # coding keys response - this will be e.g. the freetext plaintext for "Other" or whatever the user has
                # written in.
                answer_text = str(response)

                # This if condition should not trigger for truly independent free text questions
                if set_only_additional_answer and (
                    answer_text == "nan" or answer_text is None
                ):
                    print("Skipping save due to 'nan' additional answer")
                    continue

                print(child_row)

                print(
                    "Saving user free text(either independent or connected)! to:",
                    answer_text,
                )
                if get_question_filled_in_to_parent(questions_configured_df, variable):
                    print("Saving parent answer..", answer_text)
                    found_base_question, answer = update_or_create_user_answer(
                        session,
                        user_or_child_id=get_childs_parent_id(
                            session, child_row["CASE"]
                        ),
                        question_id=question.id,
                        answer_text=answer_text,
                        set_only_additional_answer=set_only_additional_answer,
                        is_child_question=False,
                    )
                    print(
                        "Question ID: ",
                        question.id,
                        "Saved it for user(parent) ID of...:",
                        get_childs_parent_id(session, child_row["CASE"]),
                    )
                else:
                    print("Saving child answer..", answer_text)
                    found_base_question, answer = update_or_create_user_answer(
                        session,
                        user_or_child_id=child_row["CASE"],
                        question_id=question.id,
                        answer_text=answer_text,
                        set_only_additional_answer=set_only_additional_answer,
                        is_child_question=True,
                    )
                # not sure this will work for free text other cases.
                total_answers += 1
                session.add(answer)
                # problem is that this shouldbe created or update too..
            else:
                print("Variable type has no clear processing method! Warning.")
                print(
                    variable_type,
                    "... it has the variable type/label:",
                    variable_type,
                    variable_label,
                )
                missing += 1
            previous_variable_label = variable_label
            previous_variable = variable

    session.commit()
    if debug:
        print("Total answers saved: ", total_answers)
        print(
            "Missing (unable to deal with answers, to which we saved the questions, so wanted the answers): ",
            missing,
        )


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 1 or len(sys.argv) > 2:
        print(
            "Usage: python import_childrens_question_answers_data.py <?clear_existing_questions bool>"
        )
        sys.exit(1)

    clear_existing_questions_and_answers = False
    if len(sys.argv) > 1:
        clear_existing_questions_and_answers = sys.argv[1] == "true"

    if clear_existing_questions_and_answers and (
        input(
            "This will wipe your DB data on questions/answers! Are you certain you want to *delete all such data*? (y/n)"
        )
        != "y"
    ):
        exit()

    import_session, import_engine = get_import_test_session()

    import_childrens_question_answers_data(
        import_session, labels_path, data_path, questions_configured_path
    )

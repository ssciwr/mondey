"""

todo: Correct this documentation, it has became outdated with the new additional data import code.
This file should parse each column and if it is a childs question, save it.
Select options will (as in `ChildQuestion` class/SQL model) just be saved as plaintext answers.

Care must be taken for freetext options. Those seem to be generally indicated by a "_" or "_01" affix to the question,
e.g.:

FE03 <-- will be a code-mapped answer
FE03_01 <-- optional freetext answer (when present, overwrites the code-mapped answer)

They are also easy to tell apart because the "Type" will be "TEXT" not "ORDINAL". e.g.

FE01 <-- ORDINAL (e.g. 1, 2, 3, 4, 5, 6, 7 -9) (where these are mapped to 1 = Deutschland, 2 = Sweden, usw).
FE01_031 <-- TEXT (e.g. "Frankreich")

Notes:

    We use variable + ': ' + variable_label for the question ID (so "FE06: Geburtsjahr") because there are some
    complexities in the question mapping from the SoSci data, especially:
    1) For answers, each possibly mappable answer response duplicates the question...
    e.g.
    Variable | Name | Code | Label
    FE04 Geburtsjahr 1 2024
    FE04 Geburtsjahr 2 2023
    FE04 Geburtsjahr 3 2022

    ... But more than this...

    The same question might appear again (e.g. in reference to the Parent/Beobachter, not the child):
    Variable | Name | Code | Label
    FK04 Geburtsjahr 1 1972
    FK04 Geburtsjahr 2 1973
    FK04 Geburtsjahr 3 1974

    So the *same Name*, *same Codes*, but Different Labels if the "Variable" (really "variable ID") is the same.
    Since variable ID also gets duplicated nAnswers times, the logic keeps within our system the variable tag
    alongside the label at all times. This way we can be sure we actually have got the respective FE04 vs FK04
    Geburtsjahr question/answers data, to avoid confusing those two. This way is also more dynamic. No combinations
    (because of how SoSci exports) should ever have the same variable and name unless they are mapping the same set
    of answers, like our code processed them. Yes it does mean in the UI the "Variable"(string ID) will appear as a
    prefix, but that's a great traddeoff to have certainty in the variables being in the actual data.
"""

import json

import pandas as pd
from sqlmodel import select

from mondey_backend.import_data.hardcoded_additional_data_answer_saving import (
    hardcoded_id_map,
)
from mondey_backend.import_data.hardcoded_additional_data_answer_saving import (
    hardcoded_other_answers,
)
from mondey_backend.import_data.hardcoded_additional_data_answer_saving import (
    process_special_answer,
)
from mondey_backend.import_data.hardcoded_additional_data_answer_saving import (
    relevant_child_variables,
)
from mondey_backend.import_data.hardcoded_additional_data_answer_saving import (
    should_be_saved,
)
from mondey_backend.import_data.utils import create_answer
from mondey_backend.import_data.utils import data_path
from mondey_backend.import_data.utils import get_childs_parent_id
from mondey_backend.import_data.utils import get_import_test_session
from mondey_backend.import_data.utils import get_question_filled_in_to_parent
from mondey_backend.import_data.utils import labels_path
from mondey_backend.import_data.utils import questions_configured_path
from mondey_backend.import_data.utils import save_select_question
from mondey_backend.import_data.utils import save_text_question
from mondey_backend.models.children import Child
from mondey_backend.models.milestones import Language
from mondey_backend.models.questions import ChildQuestion
from mondey_backend.models.questions import UserQuestion

debug = True

satisfyPreCommitUnusedImportRemover = type(Language) is str


def prepare_options_json(options):
    """
    The first draft was generated by Cladue AI, to match the examples in conftest and the data format
    <select> on the frontend appears to take as input (according to Props) for Svelte Flowbite Select.
    Prepare options JSON with value, name, and disabled properties.

    Args:
        options (pd.DataFrame): DataFrame with 'Response Code' and 'Response Label' columns

    Returns:
        tuple: A tuple containing:
            - options_json (str): JSON string of options
            - options_str (str): Comma-separated list of options for display
    """
    # Filter out invalid options
    valid_options = options[options["Response Code"] != -9]

    # Prepare options with proper escaping and structure
    prepared_options = []
    options_display = []

    for _, row in valid_options.iterrows():
        # Escape commas and other potential problematic characters in the label
        escaped_label = row["Response Label"].replace(",", "&#44;")

        option = {
            "value": str(row["Response Code"]),  # Convert to string
            "name": escaped_label,
            "disabled": False,
        }
        prepared_options.append(option)
        options_display.append(escaped_label)

    # Convert to JSON string
    options_json = json.dumps(prepared_options)

    # Create comma-separated string of options (with escaped labels)
    options_str = ";".join(options_display)

    return options_json, options_str


def import_childrens_question_answers_data(
    session,
    labels_path: str,
    data_path: str,
    questions_configured_path: str,
):
    print("Importing the questions for our data...")
    """
    This loads the "labels_df" which is in social science terms a "coding codebook". It lists several variables, which
    represent Milestones and Questions in our system, with IDs like "DE01_02". It also lists answer options for each
    "variable" with a mapping pairing, which "codes" the survey data value to the actual (text) answer. For example,
    1 = 2024, 2 = 2023, 3 = 2020. The labels_df tells us this mapping for the question "FK_01", with the title,
    "Geburtsjahr" - Year of birth.

    Questions can include "codes" like -9, which means "no answer given".

    This coding mapping is then used by the second main function in this file, assign_answers_to_the_imported_questions,
    which uses the "data_path" dataframe. The data dataframe contains the codes for each child, so it provides a way to
    map the actual answers, "using" the codebook. The second function maps those codes to save the real, true freetext
    answers, which are compatible and match the questions saved by this function.

    :param session: Important: This should be the import_session, so that we can keep it in it's own DB/folder location
    (/import_data/db by default)
    :param clear_existing_questions_and_answers: A dataframe which includes whether a question is directed to parents (so, a
    UserQuestion/UserAnswer), such as income/Social Economic Status, or about/to the child (ChildQuestion/ChildAnswer)
    :return:
    """
    if debug:
        print("Opening labels path: ", labels_path)
        print("Opening data path: ", data_path)
    if satisfyPreCommitUnusedImportRemover:
        print("Satisfied pre-commit so we can have language model table access...")

    labels_df = pd.read_csv(
        labels_path,
        sep=",",
        encoding="utf-16",
        encoding_errors="replace",
        index_col=None,
    )
    data_df = pd.read_csv(
        data_path, sep="\t", encoding="utf-16", encoding_errors="replace"
    )
    questions_configured_df = pd.read_csv(
        questions_configured_path,
        sep=",",
        encoding="utf-8",
        dtype=str,
        encoding_errors="replace",
    )
    questions_configured_df.columns = questions_configured_df.columns.str.strip()

    free_text_questions = []

    # Dictionary to track the previous variable for handling 'Andere' cases
    previous_variable_label = None

    # Process each unique variable in labels_df
    processed_variables = set()
    if debug:
        print("Sample data:")
        print(labels_df.head(5))

    if debug:
        print(
            "Now filtering out the milestones, so we only consider manual questions. This is unfortunately hardcoded."
        )

    labels_df = labels_df.loc[(labels_df.index > 170) & (labels_df.index < 395)]

    if debug:
        print("Sample data:")
        print(labels_df.head(100))

    for _uj, label_row in (
        labels_df.groupby("Variable").first().reset_index().iterrows()
    ):
        variable = label_row["Variable"]
        if debug:
            print(label_row)
            print("has variable: ", variable)

        # Skip if already processed
        if variable in processed_variables:
            continue
        processed_variables.add(variable)

        # Determine question type and properties
        variable_type = label_row["Variable Type"]
        input_type = label_row["Input Type"]
        variable_label = label_row["Variable Label"]

        # Handling different variable types
        if (
            (variable_type == "NOMINAL" or variable_type == "ORDINAL")
            and input_type == "MC"
        ) or (variable_type == "DICHOTOMOUS" and input_type == "CK"):
            if debug:
                print(
                    "Handling Multiple Choice with options.. should be saved as separated text strings"
                )
            # Multiple Choice Question
            print("Should just be saved.")
            options = labels_df[labels_df["Variable"] == variable]
            if debug:
                print("Options found were: ", options)

            # Filter out non-response codes
            valid_options = options[options["Response Code"] != -9]

            # Prepare options JSON
            options_dict = {
                str(row["Response Code"]): row["Response Label"]
                for _, row in valid_options.iterrows()
            }

            if debug:
                print("Sample options: ", options_dict)

            options_json, options_str = prepare_options_json(options)

            save_select_question(
                variable,
                variable_label,
                options_json,
                options_str,
                questions_configured_df,
                session,
            )

            # Track this as the previous variable for potential 'Andere' handling
            previous_variable_label = variable_label
            # previous_variable_label = variable_label

        elif variable_type == "TEXT" and input_type == "TXT":
            # These are free text questions
            if (
                type(variable_label) is str
                and ": [01]" in variable_label
                and (
                    previous_variable_label
                    and f"{previous_variable_label}: [01]"
                    in variable_label  # this line checks if previous was a select
                    # situation or whether it's an actual indepedent free text question (then will be False)
                )
            ):  # only if they match
                """
                In this IF case, it's an other free text input, we handle in general data processing rules for TEXT
                variable type later on, so we "continue".

                Note that some samples should not trigger this... for example:
                 FK04_01: Frühgeboren
                The previous question is on FK03,Termingebunden? so this one gets kept.
                Whereas Muttersprache, it's like
                FE04,Muttersprache,1,Deutsch,NOMINAL,MC
                FE04,Muttersprache,2,Andere,NOMINAL,MC
                FE04,Muttersprache,-9,nicht beantwortet,NOMINAL,MC
                FE05_01,Andere Muttersprache: [01],,,TEXT,TXT
                ... where "Muttersprache" is in common.
                """
                if debug:
                    print(
                        "Not creating question for this Other option - its free text response will be merged"
                    )
                continue

            # Independent free text question
            free_text_questions.append((variable, variable_label))

            save_text_question(
                variable,
                variable_label,
                previous_variable_label,
                questions_configured_df,
                session,
            )
            if debug:
                print("Added text feetex tquestion type..")
        else:
            if debug:
                print(
                    "Question case was not hanlded... need to pay attention to this..",
                    variable_label,
                    variable_type,
                    input_type,
                )

    session.commit()
    print("All questions have been generated. Now assigning answers to them")
    assign_answers_to_the_imported_questions(
        session,
        data_df,
        labels_df,
        questions_configured_df,
        appending_additional_data=False,
    )


def assign_answers_to_the_imported_questions(
    session,
    data_df,
    labels_df,
    questions_configured_df,
    appending_additional_data=False,
):
    """
    Once the questions have been inserted into UserQuestion and ChildQuestion, we need to add answers.
    This script works out the coding mappings for answers* and then connects the relevant answer and child/user ID
    to save answers for each question.

    Once complete the answers will all be imported. The logic deals with "free text other" answers by saving them
    as their own answer (as simple "answer property") if they are an independent question, or by saving it as
    "additioanl_answer" if it is connected to a select question, e.g.

    "Name": Independent free text, saves "answer" to the question.
    "Other Nationality": Exists with the "Nationality" Select question, which has an option for Other (Andere).
    When uses select Other, this one will be filled out. In that case, we set the additional answer to the "Nationality"
    question with the answer from this text field, rather than saving it as its own independent question. This leaves
    it looking like so:
    answer: "Andere", additional_answer: "Users Free text answer".

    When answers already exist for a given child/user ID, it will not insert a second answer. This is to support importing
    additional data.

    :param questions_configured_df: A dataframe which includes whether a question is directed to parents (so, a
    UserQuestion/UserAnswer), such as income/Social Economic Status, or about/to the child (ChildQuestion/ChildAnswer)

    """
    questions_to_discard = [
        "FK01",
        "FK02",
    ]  # Child date of month/year: Already assigned to each child.
    total_answers = 0
    missing = 0

    child_case_to_id_map = {}
    # get all children with their ID and name fields
    children = session.exec(
        select(Child.id, Child.name).where(Child.name.like("Imported Child %"))
    ).all()

    for child_id, child_name in children:
        # Extract case_id from the name format "Imported Child {case_id}"
        if child_name.startswith("Imported Child "):
            try:
                case_id = child_name.replace("Imported Child ", "")
                child_case_to_id_map[case_id] = child_id
            except Exception as e:
                # Handle any parsing errors
                print(f"Error processing child name '{child_name}': {e}")

    # Process actual data into child answers
    for _, child_row in data_df.iterrows():
        print("")
        print("")
        print("")
        # First: If the child has any answers, we assume their data is complete (previously imported). So skip such children
        # Iterate through all variables in labels_df
        print("")
        print("Going through for child ... ", child_row.get("CASE"))
        print("CASE ID map:", child_case_to_id_map)
        for _j, label_row in (
            labels_df.groupby("Variable").first().reset_index().iterrows()
        ):
            db_child_id = child_case_to_id_map[str(child_row.get("CASE"))]
            variable_type = label_row["Variable Type"]
            variable = label_row["Variable"]
            variable_label = label_row["Variable Label"]
            print("Doing variable: ", variable, variable_label)

            if variable_label in questions_to_discard:
                continue

            # The below enables us to find all 3 categories of possible questions for these answers:
            """
            Category 1 - variable_label is question (most questions): Just finds it as child or user question.
            Category 2 - variable_label is a free text reference, but to a question with choices. In this case,
            the replaced version will find the right original question to "overwrite" the "Other" answer with
            the freetext from the users data.
            Category 3 - variable_label is a free text reference, but not connected to another question. In this case,
            it will be found through variable level like any other question.
            """
            if appending_additional_data and (
                variable not in list(hardcoded_id_map.keys())
            ):
                print(
                    "Skipping variable which was not in our variable allowlist: ",
                    variable,
                )
                print(list(hardcoded_id_map.keys()))
                continue
            response = child_row.get(variable)
            if should_be_saved(variable):
                response_label = labels_df[
                    (labels_df["Variable"] == variable)
                    & (labels_df["Response Code"] == response)
                ]

                if response_label.empty:
                    continue  # no data entered.
                answer = (
                    response_label.iloc[0]["Response Label"]
                    if (
                        variable_type == "NOMINAL"
                        or variable_type == "ORDINAL"
                        or variable_type == "DICHOTOMOUS"
                    )
                    else response_label
                )  # will be raw freetext/number, e.g. for questions 17/18 for child (Older/younger siblings)
                print("Answer was set to:", answer)

                have_acted_upon_question = process_special_answer(
                    session, variable_label, answer, variable, child_row.get("CASE")
                )
                if have_acted_upon_question:  # saved/processsed by our hardcoded script
                    continue
            preserved_freetext_lookup_key = variable
            set_only_additional_answer = False
            # move this logic into special processing.
            if variable in hardcoded_other_answers:
                set_only_additional_answer = True
                variable = hardcoded_other_answers[
                    variable
                ]  # find the real parent ID for this
                # wll be used later when saving.
                print("Was linked to previous select, so setting additional answer")
                print(variable)

            # Find the corresponding ChildQuestion
            child_query = select(ChildQuestion).where(
                ChildQuestion.id == hardcoded_id_map[variable]
            )
            user_query = select(UserQuestion).where(
                UserQuestion.id == hardcoded_id_map[variable]
            )

            question = session.exec(
                child_query if variable in relevant_child_variables else user_query
            ).first()

            # If after all looping no match is found, discard.
            if not question:
                print(
                    "Discarding question answer without found saved question (which was deliberately not saved, maybe because it was a milestone etc): ",
                    variable,
                    label_row["Variable Label"],
                    "Answer:",
                    str(
                        labels_df[
                            (labels_df["Variable"] == variable)
                            & (labels_df["Response Code"] == response)
                        ]
                    ),
                )
                questions_to_discard.append(variable)
                # raise("This should not happen")
                continue

            # Skip if no response
            if pd.isna(response) or response == -9:
                continue

            # Handle Multiple Choice
            if (
                variable_type == "NOMINAL"
                or variable_type == "ORDINAL"
                or variable_type == "DICHOTOMOUS"
            ):
                if debug:
                    print("Came across select question type...")
                response_label = labels_df[
                    (labels_df["Variable"] == variable)
                    & (labels_df["Response Code"] == response)
                ]
                if debug:
                    print(
                        "Response/Response label: ", response, "../..", response_label
                    )
                    print("ANd desired variable: ", variable)

                if not response_label.empty:
                    answer_text = response_label.iloc[0]["Response Label"]
                    print("Saving answer:", answer_text)
                    print("Whereas response label was:", response_label)

                    if get_question_filled_in_to_parent(
                        questions_configured_df, variable, debug_print=True
                    ):
                        print("Now updating/creating user answer..")
                        # goes through here.
                        found_base_question, answer = create_answer(
                            session,
                            user_or_child_id=get_childs_parent_id(
                                session, child_row.get("CASE")
                            ),
                            question_id=question.id,
                            answer_text=answer_text,
                            set_only_additional_answer=set_only_additional_answer,
                            is_child_question=False,
                        )
                        print(
                            "Saved(user question) with parent ID of...:",
                            get_childs_parent_id(session, child_row.get("CASE")),
                        )
                    else:
                        print(
                            "Would have looked up isToParent Y status for: ", variable
                        )
                        found_base_question, answer = create_answer(
                            session,
                            user_or_child_id=db_child_id,
                            question_id=question.id,
                            answer_text=answer_text,
                            set_only_additional_answer=set_only_additional_answer,
                            is_child_question=True,
                        )
                    total_answers += 1
                    session.add(answer)

            elif variable_type == "TEXT":
                print("Encountered text variable type.", variable, variable_label)
                if " [01]" in variable_label and "Andere" in variable_label:
                    if debug:
                        print("Free text Andere triggered!", variable, variable_label)

                    set_only_additional_answer = True

                response = child_row.get(
                    preserved_freetext_lookup_key
                )  # For free text, always use the actual look up
                # coding keys response - this will be e.g. the freetext plaintext for "Other" or whatever the user has
                # written in.
                answer_text = str(
                    response
                )  # it will be the direct response, not a look up code.

                # This if condition should not trigger for truly independent free text questions
                if set_only_additional_answer and (
                    answer_text == "nan" or answer_text is None
                ):
                    print("Skipping save due to 'nan' additional answer")
                    continue

                print(child_row)

                print(
                    "Saving user free text(either independent or connected)! to:",
                    answer_text,
                )
                if get_question_filled_in_to_parent(questions_configured_df, variable):
                    print("Saving parent answer..", answer_text)
                    found_base_question, answer = create_answer(
                        session,
                        user_or_child_id=get_childs_parent_id(
                            session, child_row.get("CASE")
                        ),
                        question_id=question.id,
                        answer_text=answer_text,
                        set_only_additional_answer=set_only_additional_answer,
                        is_child_question=False,
                    )
                else:
                    print("Saving child answer..", answer_text)
                    found_base_question, answer = create_answer(
                        session,
                        user_or_child_id=db_child_id,
                        question_id=question.id,
                        answer_text=answer_text,
                        set_only_additional_answer=set_only_additional_answer,
                        is_child_question=True,
                    )
                # not sure this will work for free text other cases.
                total_answers += 1
                session.add(answer)
                # problem is that this shouldbe created or update too..
            else:
                print("Variable type has no clear processing method! Warning.")
                print(
                    variable_type,
                    "... it has the variable type/label:",
                    variable_type,
                    variable_label,
                )
                missing += 1

    session.commit()
    if debug:
        print("Total answers saved: ", total_answers)
        print(
            "Missing (unable to deal with answers, to which we saved the questions, so wanted the answers): ",
            missing,
        )


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 1 or len(sys.argv) > 2:
        print(
            "Usage: python import_childrens_question_answers_data.py <?clear_existing_questions bool>"
        )
        sys.exit(1)

    clear_existing_questions_and_answers = False
    if len(sys.argv) > 1:
        clear_existing_questions_and_answers = sys.argv[1] == "true"

    if clear_existing_questions_and_answers and (
        input(
            "This will wipe your DB data on questions/answers! Are you certain you want to *delete all such data*? (y/n)"
        )
        != "y"
    ):
        exit()

    import_session, import_engine = get_import_test_session()

    import_childrens_question_answers_data(
        import_session, labels_path, data_path, questions_configured_path
    )
